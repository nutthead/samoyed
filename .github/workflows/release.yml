# =============================================================================
# SAMOYED RELEASE AUTOMATION WORKFLOW
# =============================================================================
#
# WHAT: Fully automated release pipeline for Samoyed git hooks manager
# WHY: Ensures consistent, reliable releases across multiple platforms
# FEATURES:
#   - Cross-platform binary builds (Linux, macOS, Windows)
#   - Automated changelog generation from conventional commits
#   - GitHub release creation with artifacts
#   - Conditional crates.io publishing (stable releases only)
#   - Post-release automation (issue notifications, summaries)
#
# TRIGGER CONDITIONS:
#   - Version tags: v1.0.0, v1.0.0-beta.1, etc. (semantic versioning)
#   - Manual dispatch: For testing and emergency releases
#
# RELEASE PIPELINE:
#   1. Validate version consistency between tag and Cargo.toml
#   2. Build optimized binaries for all supported platforms
#   3. Generate structured changelog from git commit history
#   4. Create GitHub release with downloadable artifacts
#   5. Publish to crates.io registry (stable releases only)
#   6. Execute post-release tasks (notifications, summaries)

name: üöÄ Release

# =============================================================================
# WORKFLOW PERMISSIONS
# =============================================================================
# WHAT: GitHub token permissions required for release operations
# WHY: Principle of least privilege - only request necessary permissions
# CONTENTS: write - Create releases, upload artifacts
# PULL-REQUESTS: write - Comment on PRs related to releases
# ISSUES: write - Comment on issues resolved in releases
permissions:
  contents: write
  pull-requests: write
  issues: write

# =============================================================================
# WORKFLOW TRIGGER CONFIGURATION
# =============================================================================
# WHAT: Defines when this release workflow executes
# WHY: Enables both automated (tag-based) and manual releases
on:
  push:
    tags:
      # SYNTAX: Regex pattern for semantic version tags
      # MATCHES: v1.0.0, v2.1.3, v1.0.0-beta.1, v2.0.0-rc.1
      # FORMAT: v{major}.{minor}.{patch}[-{prerelease}]
      - 'v[0-9]+.[0-9]+.[0-9]+*'
  
  # WHAT: Manual workflow trigger with configurable inputs
  # WHY: Allows testing releases, emergency releases, or custom versions
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 0.1.0)'
        required: true
        type: string  # GitHub Actions input type for text
      dry_run:
        description: 'Dry run (skip publishing)'
        required: false
        type: boolean  # GitHub Actions input type for checkboxes
        default: false

# =============================================================================
# GLOBAL ENVIRONMENT VARIABLES
# =============================================================================
# WHAT: Environment variables available to all jobs in this workflow
# WHY: Consistent configuration for optimal debugging and output
env:
  CARGO_TERM_COLOR: always  # Force colored Cargo output in CI logs
  RUST_BACKTRACE: 1         # Enable detailed stack traces on panics

jobs:
  # =============================================================================
  # JOB 1: RELEASE PREPARATION AND VALIDATION
  # =============================================================================
  # WHAT: Validates version consistency and prepares release metadata
  # WHY: Prevents releases with mismatched versions or invalid tags
  # OUTPUTS: Provides version info and prerelease status to dependent jobs
  prepare:
    name: üîç Prepare Release
    runs-on: ubuntu-latest
    # Job outputs that other jobs can reference via needs.prepare.outputs.*
    # These values determine release behavior (crates.io publishing, GitHub release type)
    outputs:
      version: ${{ steps.version.outputs.version }}           # Semantic version (e.g., "1.0.0")
      is_prerelease: ${{ steps.version.outputs.is_prerelease }} # Boolean string indicating pre-release
      
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          # WHAT: fetch-depth: 0 downloads complete git history
          # WHY: Required for changelog generation (git log, tag comparison)
          # DEFAULT: fetch-depth: 1 (shallow clone) insufficient for releases
          fetch-depth: 0

      - name: üè∑Ô∏è Determine version
        id: version  # Step ID for referencing outputs in other steps
        run: |
          # =================================================================
          # VERSION EXTRACTION LOGIC
          # =================================================================
          # WHAT: Extract version from trigger source (tag or manual input)
          # WHY: Support both automated tag-based and manual releases
          # SYNTAX: github.event_name is built-in context variable
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual trigger: use provided version input
            VERSION="${{ github.event.inputs.version }}"
            TAG="v${VERSION}"  # Prefix with 'v' for consistency
          else
            # Tag trigger: extract version from tag name
            TAG="${{ github.ref_name }}"  # github.ref_name contains tag name
            VERSION="${TAG#v}"           # Remove 'v' prefix using bash parameter expansion
          fi
          
          # WHAT: Set step outputs for use in other jobs
          # SYNTAX: >> $GITHUB_OUTPUT is GitHub Actions method to set outputs
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          
          # WHAT: Determine if this is a pre-release version
          # WHY: Pre-releases skip crates.io publishing and use different GitHub release flags
          # LOGIC: Semantic version with hyphen indicates pre-release (e.g., 1.0.0-beta.1)
          # SYNTAX: [[ "$VERSION" =~ "-" ]] is bash regex matching
          if [[ "$VERSION" =~ "-" ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "üì¶ Pre-release version detected: ${VERSION}"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "üì¶ Release version: ${VERSION}"
          fi

      - name: üîç Validate Cargo.toml version
        run: |
          # =================================================================
          # VERSION CONSISTENCY VALIDATION
          # =================================================================
          # WHAT: Ensure Cargo.toml version matches release tag
          # WHY: Prevents publishing releases with incorrect version metadata
          # CRITICAL: Cargo publish uses Cargo.toml version, must match tag
          
          # SYNTAX: Pipeline of commands to extract version from Cargo.toml
          # grep -E "^version" - Find lines starting with "version"
          # head -1 - Take first match (main package version)
          # cut -d'"' -f2 - Split on quotes, take second field (version string)
          CARGO_VERSION=$(grep -E "^version" Cargo.toml | head -1 | cut -d'"' -f2)
          EXPECTED_VERSION="${{ steps.version.outputs.version }}"
          
          # WHAT: Compare versions and fail if mismatch
          # WHY: Version mismatch would cause publish failures or incorrect releases
          if [[ "$CARGO_VERSION" != "$EXPECTED_VERSION" ]]; then
            echo "‚ùå Version mismatch!"
            echo "Cargo.toml version: ${CARGO_VERSION}"
            echo "Release version: ${EXPECTED_VERSION}"
            echo ""
            echo "Please update Cargo.toml version to match the release tag."
            exit 1  # Fail the workflow with error exit code
          fi
          
          echo "‚úÖ Version validated: ${CARGO_VERSION}"

  # Build release binaries for all platforms
  build:
    name: üèóÔ∏è Build ${{ matrix.target }}
    needs: prepare
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux builds
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            archive: tar.gz
          - target: aarch64-unknown-linux-gnu
            os: ubuntu-latest
            archive: tar.gz
            cross: true
          
          # macOS builds
          - target: x86_64-apple-darwin
            os: macos-latest
            archive: tar.gz
          - target: aarch64-apple-darwin
            os: macos-latest
            archive: tar.gz
          
          # Windows builds
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            archive: zip
          - target: i686-pc-windows-msvc
            os: windows-latest
            archive: zip

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: ü¶Ä Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: üì¶ Install cross-compilation tools
        if: matrix.cross
        run: |
          cargo install cross --git https://github.com/cross-rs/cross

      - name: üì¶ Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
            ${{ matrix.cross && 'target/cross-*' || '' }}
          key: ${{ runner.os }}-cargo-release-${{ matrix.target }}-${{ matrix.cross && 'cross-' || '' }}${{ hashFiles('Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-release-${{ matrix.target }}-${{ matrix.cross && 'cross-' || '' }}
            ${{ runner.os }}-cargo-release-${{ matrix.target }}-
            ${{ runner.os }}-cargo-

      - name: üßπ Clean target directory for cross-compilation
        if: matrix.cross
        run: |
          # Clean target directory to avoid cargo caching issues with build scripts
          # This prevents GLIBC version mismatches when build scripts are reused across targets
          echo "üßπ Cleaning target directory for cross-compilation..."
          cargo clean
        shell: bash

      - name: üèóÔ∏è Build release binaries
        run: |
          if [[ "${{ matrix.cross }}" == "true" ]]; then
            # Use separate target directory for cross-compilation to avoid conflicts
            export CARGO_TARGET_DIR="target/cross-${{ matrix.target }}"
            cross build --release --target ${{ matrix.target }} --verbose
          else
            cargo build --release --target ${{ matrix.target }} --verbose
          fi
        shell: bash

      - name: üì¶ Package release (Unix)
        if: matrix.archive == 'tar.gz'
        run: |
          # Determine target directory based on cross-compilation
          if [[ "${{ matrix.cross }}" == "true" ]]; then
            TARGET_DIR="target/cross-${{ matrix.target }}/${{ matrix.target }}/release"
          else
            TARGET_DIR="target/${{ matrix.target }}/release"
          fi
          
          # Package from the target directory
          ASSET_NAME="samoyed-${{ needs.prepare.outputs.version }}-${{ matrix.target }}.tar.gz"
          tar czf "${ASSET_NAME}" -C "${TARGET_DIR}" samoyed samoyed-hook
          echo "ASSET=${ASSET_NAME}" >> $GITHUB_ENV

      - name: üì¶ Package release (Windows)
        if: matrix.archive == 'zip'
        shell: bash
        run: |
          # Determine target directory based on cross-compilation
          if [[ "${{ matrix.cross }}" == "true" ]]; then
            TARGET_DIR="target/cross-${{ matrix.target }}/${{ matrix.target }}/release"
          else
            TARGET_DIR="target/${{ matrix.target }}/release"
          fi
          
          # Package from the target directory
          ASSET_NAME="samoyed-${{ needs.prepare.outputs.version }}-${{ matrix.target }}.zip"
          cd "${TARGET_DIR}"
          7z a "../../../${ASSET_NAME}" samoyed.exe samoyed-hook.exe
          cd ../../../
          echo "ASSET=${ASSET_NAME}" >> $GITHUB_ENV

      - name: üîê Setup GPG signing
        run: |
          # Import GPG private key from secrets
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          
          # List imported keys for verification
          gpg --list-secret-keys --keyid-format LONG
          
          # Get key ID for signing
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | head -1 | cut -d'/' -f2 | cut -d' ' -f1)
          echo "GPG_KEY_ID=${GPG_KEY_ID}" >> $GITHUB_ENV
          echo "üîë Using GPG key: ${GPG_KEY_ID}"

      - name: üîè Sign release artifact
        run: |
          # Sign the archive with GPG
          gpg --batch --yes --detach-sign --armor --local-user "${{ env.GPG_KEY_ID }}" "${{ env.ASSET }}"
          
          # Verify the signature was created
          ls -la "${{ env.ASSET }}.asc"
          
          echo "‚úÖ Signed: ${{ env.ASSET }}"
          echo "üìù Signature: ${{ env.ASSET }}.asc"

      - name: üì§ Upload release artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.target }}
          path: |
            ${{ env.ASSET }}
            ${{ env.ASSET }}.asc
          retention-days: 7

  # Generate changelog for the release
  changelog:
    name: üìù Generate Changelog
    needs: prepare
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üìù Generate changelog
        id: changelog
        run: |
          # Get the previous tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 ${{ needs.prepare.outputs.tag }}^ 2>/dev/null || echo "")
          
          if [[ -z "$PREVIOUS_TAG" ]]; then
            echo "üìù Generating changelog for first release..."
            RANGE=""
          else
            echo "üìù Generating changelog from ${PREVIOUS_TAG} to ${{ needs.prepare.outputs.tag }}..."
            RANGE="${PREVIOUS_TAG}..${{ needs.prepare.outputs.tag }}"
          fi
          
          # Generate changelog using git log with conventional commit parsing
          {
            echo "## What's Changed in ${{ needs.prepare.outputs.version }}"
            echo ""
            
            # Features
            FEATURES=$(git log ${RANGE} --pretty=format:"%s|%h" | grep -E "^feat(\(.*\))?:" || true)
            if [[ -n "$FEATURES" ]]; then
              echo "### ‚ú® Features"
              echo "$FEATURES" | while IFS='|' read -r message hash; do
                echo "- ${message} (${hash})"
              done
              echo ""
            fi
            
            # Bug fixes
            FIXES=$(git log ${RANGE} --pretty=format:"%s|%h" | grep -E "^fix(\(.*\))?:" || true)
            if [[ -n "$FIXES" ]]; then
              echo "### üêõ Bug Fixes"
              echo "$FIXES" | while IFS='|' read -r message hash; do
                echo "- ${message} (${hash})"
              done
              echo ""
            fi
            
            # Performance improvements
            PERF=$(git log ${RANGE} --pretty=format:"%s|%h" | grep -E "^perf(\(.*\))?:" || true)
            if [[ -n "$PERF" ]]; then
              echo "### ‚ö° Performance"
              echo "$PERF" | while IFS='|' read -r message hash; do
                echo "- ${message} (${hash})"
              done
              echo ""
            fi
            
            # Other changes
            OTHERS=$(git log ${RANGE} --pretty=format:"%s|%h" | grep -vE "^(feat|fix|perf|docs|test|chore|ci|build|style|refactor)(\(.*\))?:" || true)
            if [[ -n "$OTHERS" ]]; then
              echo "### üì¶ Other Changes"
              echo "$OTHERS" | while IFS='|' read -r message hash; do
                echo "- ${message} (${hash})"
              done
              echo ""
            fi
            
            # Contributors
            echo "### üë• Contributors"
            git log ${RANGE} --pretty=format:"%an|%ae" | sort | uniq | while IFS='|' read -r author email; do
              # Map author names/emails to GitHub usernames
              case "$email" in
                "hello@behrang.org"|"behrangsa@gmail.com")
                  echo "- @behrangsa"
                  ;;
                *)
                  # For unknown contributors, use author name without @ prefix to avoid incorrect mentions
                  echo "- ${author}"
                  ;;
              esac
            done
            echo ""
            
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${{ needs.prepare.outputs.tag }}"
          } > CHANGELOG.md
          
          # Save changelog for release body
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          cat CHANGELOG.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: üì§ Upload changelog
        uses: actions/upload-artifact@v4
        with:
          name: changelog
          path: CHANGELOG.md
          retention-days: 7

  # Create GitHub release
  release:
    name: üöÄ Create Release
    needs: [prepare, build, changelog]
    runs-on: ubuntu-latest
    if: github.event.inputs.dry_run != 'true'
    
    steps:
      - name: üì• Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: üìã List artifacts
        run: |
          echo "üì¶ Release artifacts:"
          find artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" \) | sort
          echo ""
          echo "üîê GPG signatures:"
          find artifacts -type f -name "*.asc" | sort

      - name: üöÄ Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare.outputs.version }}
          name: Samoyed v${{ needs.prepare.outputs.version }}
          body_path: artifacts/changelog/CHANGELOG.md
          prerelease: ${{ needs.prepare.outputs.is_prerelease }}
          files: |
            artifacts/release-*/*
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Publish to crates.io
  publish:
    name: üì¶ Publish to crates.io
    needs: [prepare, release]
    runs-on: ubuntu-latest
    if: |
      github.event.inputs.dry_run != 'true' &&
      needs.prepare.outputs.is_prerelease == 'false'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: ü¶Ä Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: üì¶ Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-publish-${{ hashFiles('Cargo.lock') }}

      - name: üîç Verify package
        run: |
          cargo package --verbose
          cargo package --list

      - name: üì§ Publish to crates.io
        run: |
          cargo publish --verbose
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

  # Post-release tasks
  post_release:
    name: üìã Post-Release Tasks
    needs: [prepare, release]
    runs-on: ubuntu-latest
    if: github.event.inputs.dry_run != 'true'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üí¨ Comment on related issues
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ needs.prepare.outputs.version }}';
            const releaseUrl = `https://github.com/${{ github.repository }}/releases/tag/v${version}`;
            
            // Find issues that mention this version
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'release'
            });
            
            for (const issue of issues.data) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `üöÄ Released in [v${version}](${releaseUrl})!`
              });
            }

      - name: üìä Generate release summary
        run: |
          echo "# üöÄ Release Summary: v${{ needs.prepare.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìã Release Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Version** | v${{ needs.prepare.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Type** | ${{ needs.prepare.outputs.is_prerelease == 'true' && 'Pre-release' || 'Stable Release' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Release URL** | https://github.com/${{ github.repository }}/releases/tag/v${{ needs.prepare.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Crates.io** | ${{ needs.prepare.outputs.is_prerelease == 'false' && '‚úÖ Published' || '‚è≠Ô∏è Skipped (pre-release)' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üéØ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify the release artifacts work correctly" >> $GITHUB_STEP_SUMMARY
          echo "2. Update documentation if needed" >> $GITHUB_STEP_SUMMARY
          echo "3. Announce the release" >> $GITHUB_STEP_SUMMARY