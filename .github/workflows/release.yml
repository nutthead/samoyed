# =============================================================================
# SAMOYED RELEASE AUTOMATION WORKFLOW
# =============================================================================
#
# WHAT: Fully automated release pipeline for Samoyed git hooks manager
# WHY: Ensures consistent, reliable releases across multiple platforms
# FEATURES:
#   - Cross-platform binary builds (Linux, macOS, Windows)
#   - GPG signing of all release artifacts
#   - Automated changelog generation from conventional commits
#   - GitHub release creation with artifacts
#   - Conditional crates.io publishing (stable releases only)
#   - Post-release automation (issue notifications, summaries)
#
# TRIGGER CONDITIONS:
#   - Version tags: v1.0.0, v1.0.0-beta.1, etc. (semantic versioning)
#   - Manual dispatch: For testing and emergency releases
#
# RELEASE PIPELINE:
#   1. Validate version consistency between tag and Cargo.toml
#   2. Build optimized binaries for all supported platforms
#   3. Generate structured changelog from git commit history
#   4. Sign all release artifacts with GPG
#   5. Create GitHub release with downloadable artifacts
#   6. Publish to crates.io registry (stable releases only)
#   7. Execute post-release tasks (notifications, summaries)

name: ðŸš€ Release

# =============================================================================
# WORKFLOW PERMISSIONS
# =============================================================================
# WHAT: GitHub token permissions required for release operations
# WHY: Principle of least privilege - only request necessary permissions
# CONTENTS: write - Create releases, upload artifacts
# PULL-REQUESTS: write - Comment on PRs related to releases
# ISSUES: write - Comment on issues resolved in releases
permissions:
  contents: write
  pull-requests: write
  issues: write

# =============================================================================
# WORKFLOW TRIGGER CONFIGURATION
# =============================================================================
# WHAT: Defines when this release workflow executes
# WHY: Enables both automated (tag-based) and manual releases
on:
  push:
    tags:
      # SYNTAX: Regex pattern for semantic version tags
      # MATCHES: v1.0.0, v2.1.3, v1.0.0-beta.1, v2.0.0-rc.1
      # FORMAT: v{major}.{minor}.{patch}[-{prerelease}]
      - "v[0-9]+.[0-9]+.[0-9]+*"

  # WHAT: Manual workflow trigger with configurable inputs
  # WHY: Allows testing releases, emergency releases, or custom versions
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g., 0.1.0)"
        required: true
        type: string # GitHub Actions input type for text
      dry_run:
        description: "Dry run (skip publishing)"
        required: false
        type: boolean # GitHub Actions input type for checkboxes
        default: false

# =============================================================================
# GLOBAL ENVIRONMENT VARIABLES
# =============================================================================
# WHAT: Environment variables available to all jobs in this workflow
# WHY: Consistent configuration for optimal debugging and output
env:
  CARGO_TERM_COLOR: always # Force colored Cargo output in CI logs
  RUST_BACKTRACE: 1 # Enable detailed stack traces on panics

jobs:
  # =============================================================================
  # JOB 1: RELEASE PREPARATION AND VALIDATION
  # =============================================================================
  # WHAT: Validates version consistency and prepares release metadata
  # WHY: Prevents releases with mismatched versions or invalid tags
  # OUTPUTS: Provides version info and prerelease status to dependent jobs
  prepare:
    name: ðŸ” Prepare Release
    runs-on: ubuntu-latest
    # Job outputs that other jobs can reference via needs.prepare.outputs.*
    # These values determine release behavior (crates.io publishing, GitHub release type)
    outputs:
      version: ${{ steps.version.outputs.version }} # Semantic version (e.g., "1.0.0")
      is_prerelease: ${{ steps.version.outputs.is_prerelease }} # Boolean string indicating pre-release

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          # WHAT: fetch-depth: 0 downloads complete git history
          # WHY: Required for changelog generation (git log, tag comparison)
          # DEFAULT: fetch-depth: 1 (shallow clone) insufficient for releases
          fetch-depth: 0

      - name: ðŸ·ï¸ Determine version
        id: version # Step ID for referencing outputs in other steps
        run: |
          # =================================================================
          # VERSION EXTRACTION LOGIC
          # =================================================================
          # WHAT: Extract version from trigger source (tag or manual input)
          # WHY: Support both automated tag-based and manual releases
          # SYNTAX: github.event_name is built-in context variable

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual trigger: use provided version input
            VERSION="${{ github.event.inputs.version }}"
            TAG="v${VERSION}"  # Prefix with 'v' for consistency
          else
            # Tag trigger: extract version from tag name
            TAG="${{ github.ref_name }}"  # github.ref_name contains tag name
            VERSION="${TAG#v}"           # Remove 'v' prefix using bash parameter expansion
          fi

          # WHAT: Set step outputs for use in other jobs
          # SYNTAX: >> $GITHUB_OUTPUT is GitHub Actions method to set outputs
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT

          # WHAT: Determine if this is a pre-release version
          # WHY: Pre-releases skip crates.io publishing and use different GitHub release flags
          # LOGIC: Semantic version with hyphen indicates pre-release (e.g., 1.0.0-beta.1)
          # SYNTAX: [[ "$VERSION" =~ "-" ]] is bash regex matching
          if [[ "$VERSION" =~ "-" ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Pre-release version detected: ${VERSION}"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Release version: ${VERSION}"
          fi

      - name: ðŸ” Validate Cargo.toml version
        run: |
          # =================================================================
          # VERSION CONSISTENCY VALIDATION
          # =================================================================
          # WHAT: Ensure Cargo.toml version matches release tag
          # WHY: Prevents publishing releases with incorrect version metadata
          # CRITICAL: Cargo publish uses Cargo.toml version, must match tag

          # SYNTAX: Pipeline of commands to extract version from Cargo.toml
          # grep -E "^version" - Find lines starting with "version"
          # head -1 - Take first match (main package version)
          # cut -d'"' -f2 - Split on quotes, take second field (version string)
          CARGO_VERSION=$(grep -E "^version" Cargo.toml | head -1 | cut -d'"' -f2)
          EXPECTED_VERSION="${{ steps.version.outputs.version }}"

          # WHAT: Compare versions and fail if mismatch
          # WHY: Version mismatch would cause publish failures or incorrect releases
          if [[ "$CARGO_VERSION" != "$EXPECTED_VERSION" ]]; then
            echo "âŒ Version mismatch!"
            echo "Cargo.toml version: ${CARGO_VERSION}"
            echo "Release version: ${EXPECTED_VERSION}"
            echo ""
            echo "Please update Cargo.toml version to match the release tag."
            exit 1  # Fail the workflow with error exit code
          fi

          echo "âœ… Version validated: ${CARGO_VERSION}"

  # Build release binaries for all platforms
  build:
    name: ðŸ—ï¸ Build ${{ matrix.target }}
    needs: prepare
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux builds
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            archive: tar.gz
          - target: aarch64-unknown-linux-gnu
            os: ubuntu-latest
            archive: tar.gz
            cross: true

          # macOS builds
          - target: x86_64-apple-darwin
            os: macos-latest
            archive: tar.gz
          - target: aarch64-apple-darwin
            os: macos-latest
            archive: tar.gz

          # Windows builds
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            archive: zip
          - target: i686-pc-windows-msvc
            os: windows-latest
            archive: zip

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ¦€ Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: ðŸ“¦ Install cross-compilation tools
        if: matrix.cross
        run: |
          cargo install cross --git https://github.com/cross-rs/cross

      - name: ðŸ“¦ Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
            ${{ matrix.cross && 'target/cross-*' || '' }}
          key: ${{ runner.os }}-cargo-release-${{ matrix.target }}-${{ matrix.cross && 'cross-' || '' }}${{ hashFiles('Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-release-${{ matrix.target }}-${{ matrix.cross && 'cross-' || '' }}
            ${{ runner.os }}-cargo-release-${{ matrix.target }}-
            ${{ runner.os }}-cargo-

      - name: ðŸ§¹ Clean target directory for cross-compilation
        if: matrix.cross
        run: |
          # Clean target directory to avoid cargo caching issues with build scripts
          # This prevents GLIBC version mismatches when build scripts are reused across targets
          echo "ðŸ§¹ Cleaning target directory for cross-compilation..."
          cargo clean
        shell: bash

      - name: ðŸ—ï¸ Build release binaries
        run: |
          if [[ "${{ matrix.cross }}" == "true" ]]; then
            # Use separate target directory for cross-compilation to avoid conflicts
            export CARGO_TARGET_DIR="target/cross-${{ matrix.target }}"
            cross build --release --target ${{ matrix.target }} --verbose
          else
            cargo build --release --target ${{ matrix.target }} --verbose
          fi
        shell: bash

      - name: ðŸ“¦ Package release (Unix)
        if: matrix.archive == 'tar.gz'
        run: |
          # Determine target directory based on cross-compilation
          if [[ "${{ matrix.cross }}" == "true" ]]; then
            TARGET_DIR="target/cross-${{ matrix.target }}/${{ matrix.target }}/release"
          else
            TARGET_DIR="target/${{ matrix.target }}/release"
          fi

          # Package from the target directory
          ASSET_NAME="samoyed-${{ needs.prepare.outputs.version }}-${{ matrix.target }}.tar.gz"
          tar czf "${ASSET_NAME}" -C "${TARGET_DIR}" samoyed samoyed-hook
          echo "ASSET=${ASSET_NAME}" >> $GITHUB_ENV

      - name: ðŸ“¦ Package release (Windows)
        if: matrix.archive == 'zip'
        shell: bash
        run: |
          # Determine target directory based on cross-compilation
          if [[ "${{ matrix.cross }}" == "true" ]]; then
            TARGET_DIR="target/cross-${{ matrix.target }}/${{ matrix.target }}/release"
          else
            TARGET_DIR="target/${{ matrix.target }}/release"
          fi

          # Package from the target directory
          ASSET_NAME="samoyed-${{ needs.prepare.outputs.version }}-${{ matrix.target }}.zip"
          cd "${TARGET_DIR}"
          7z a "../../../${ASSET_NAME}" samoyed.exe samoyed-hook.exe
          cd ../../../
          echo "ASSET=${ASSET_NAME}" >> $GITHUB_ENV

      - name: ðŸ“¤ Upload release artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.target }}
          path: ${{ env.ASSET }}
          retention-days: 7

  # Generate changelog for the release
  changelog:
    name: ðŸ“ Generate Changelog
    needs: prepare
    runs-on: ubuntu-latest

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ“ Generate changelog
        id: changelog
        run: |
          # Get the previous tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 ${{ needs.prepare.outputs.tag }}^ 2>/dev/null || echo "")

          if [[ -z "$PREVIOUS_TAG" ]]; then
            echo "ðŸ“ Generating changelog for first release..."
            RANGE=""
          else
            echo "ðŸ“ Generating changelog from ${PREVIOUS_TAG} to ${{ needs.prepare.outputs.tag }}..."
            RANGE="${PREVIOUS_TAG}..${{ needs.prepare.outputs.tag }}"
          fi

          # Generate changelog using git log with conventional commit parsing
          {
            echo "## What's Changed in ${{ needs.prepare.outputs.version }}"
            echo ""

            # Features
            FEATURES=$(git log ${RANGE} --pretty=format:"%s|%h" | grep -E "^feat(\(.*\))?:" || true)
            if [[ -n "$FEATURES" ]]; then
              echo "### âœ¨ Features"
              echo "$FEATURES" | while IFS='|' read -r message hash; do
                echo "- ${message} (${hash})"
              done
              echo ""
            fi

            # Bug fixes
            FIXES=$(git log ${RANGE} --pretty=format:"%s|%h" | grep -E "^fix(\(.*\))?:" || true)
            if [[ -n "$FIXES" ]]; then
              echo "### ðŸ› Bug Fixes"
              echo "$FIXES" | while IFS='|' read -r message hash; do
                echo "- ${message} (${hash})"
              done
              echo ""
            fi

            # Performance improvements
            PERF=$(git log ${RANGE} --pretty=format:"%s|%h" | grep -E "^perf(\(.*\))?:" || true)
            if [[ -n "$PERF" ]]; then
              echo "### âš¡ Performance"
              echo "$PERF" | while IFS='|' read -r message hash; do
                echo "- ${message} (${hash})"
              done
              echo ""
            fi

            # Other changes
            OTHERS=$(git log ${RANGE} --pretty=format:"%s|%h" | grep -vE "^(feat|fix|perf|docs|test|chore|ci|build|style|refactor)(\(.*\))?:" || true)
            if [[ -n "$OTHERS" ]]; then
              echo "### ðŸ“¦ Other Changes"
              echo "$OTHERS" | while IFS='|' read -r message hash; do
                echo "- ${message} (${hash})"
              done
              echo ""
            fi

            # Contributors
            echo "### ðŸ‘¥ Contributors"
            git log ${RANGE} --pretty=format:"%an|%ae" | sort | uniq | while IFS='|' read -r author email; do
              # Map author names/emails to GitHub usernames
              case "$email" in
                "hello@behrang.org"|"behrangsa@gmail.com")
                  echo "- @behrangsa"
                  ;;
                *)
                  # For unknown contributors, use author name without @ prefix to avoid incorrect mentions
                  echo "- ${author}"
                  ;;
              esac
            done
            echo ""

            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${{ needs.prepare.outputs.tag }}"
          } > CHANGELOG.md

          # Save changelog for release body
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          cat CHANGELOG.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: ðŸ“¤ Upload changelog
        uses: actions/upload-artifact@v4
        with:
          name: changelog
          path: CHANGELOG.md
          retention-days: 7

  # Create GitHub release
  release:
    name: ðŸš€ Create Release
    needs: [prepare, build, changelog]
    runs-on: ubuntu-latest
    if: github.event.inputs.dry_run != 'true'

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ“¥ Download all artifacts
        uses: actions/download-artifact@v5
        with:
          path: artifacts/

      - name: ðŸ“‹ List artifacts
        run: |
          echo "ðŸ“¦ Release artifacts:"
          find artifacts -type f -name "*.tar.gz" -o -name "*.zip" | sort

      - name: ðŸ” Import GPG key
        run: |
          # Import the private key from repository secrets
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import

          # Configure GPG for non-interactive signing
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          gpgconf --reload gpg-agent

          # Verify key was imported successfully (ed25519 key)
          echo "ðŸ” Verifying GPG key import..."
          gpg --list-secret-keys --keyid-format LONG

          # Should show: sec ed25519/F7A6F8331CBBC51F
          if ! gpg --list-secret-keys --keyid-format LONG | grep -q "F7A6F8331CBBC51F"; then
            echo "âŒ GPG key import failed"
            exit 1
          fi
          echo "âœ… GPG key imported successfully"

      - name: ðŸ“œ Extract and verify public key
        run: |
          # Extract public key for distribution
          gpg --armor --export 02D1B70CF6D841EEE6876E13F7A6F8331CBBC51F > samoyed-release-public.key

          # Verify the exported public key
          echo "ðŸ” Verifying exported public key..."
          gpg --import --import-options show-only --with-fingerprint samoyed-release-public.key

          # Verify fingerprint matches expected value
          if ! gpg --import --import-options show-only --with-fingerprint samoyed-release-public.key | grep -q "02D1 B70C F6D8 41EE E687 6E13 F7A6 F833 1CBB C51F"; then
            echo "âŒ Public key fingerprint verification failed"
            exit 1
          fi
          echo "âœ… Public key exported and verified"

      - name: âœï¸ Sign release artifacts
        run: |
          echo "ðŸ” Signing release artifacts with ed25519 key..."

          # Sign each artifact with detached signature
          for file in artifacts/release-*/*.tar.gz artifacts/release-*/*.zip; do
            if [[ -f "$file" ]]; then
              echo "Signing: $(basename "$file")"

              # Create detached ASCII-armored signature with ed25519 key
              gpg --batch --yes \
                --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
                --pinentry-mode loopback \
                --armor \
                --detach-sign \
                --local-user 02D1B70CF6D841EEE6876E13F7A6F8331CBBC51F \
                --output "${file}.asc" \
                "$file"

              # Verify signature was created correctly
              if ! gpg --verify "${file}.asc" "$file"; then
                echo "âŒ Signature verification failed for $(basename "$file")"
                exit 1
              fi
              echo "âœ… Signed and verified: $(basename "$file")"
            fi
          done

      - name: ðŸ“‹ Generate and sign checksums
        run: |
          echo "ðŸ“‹ Generating SHA256 checksums..."

          # Create SHA256 checksums for all release files
          cd artifacts

          # Generate checksums for all artifacts
          {
            echo "# SHA256 Checksums for Samoyed v${{ needs.prepare.outputs.version }}"
            echo "# Generated on $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""
            find release-* -type f \( -name "*.tar.gz" -o -name "*.zip" \) -print0 | \
              xargs -0 sha256sum | sort
          } > CHECKSUMS.txt

          echo "ðŸ“‹ Checksums generated:"
          cat CHECKSUMS.txt

          # Sign the checksums file with ed25519 key
          echo "ðŸ” Signing checksums file..."
          gpg --batch --yes \
            --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
            --pinentry-mode loopback \
            --armor \
            --detach-sign \
            --local-user 02D1B70CF6D841EEE6876E13F7A6F8331CBBC51F \
            --output CHECKSUMS.txt.asc \
            CHECKSUMS.txt

          # Verify checksums signature
          if ! gpg --verify CHECKSUMS.txt.asc CHECKSUMS.txt; then
            echo "âŒ Checksums signature verification failed"
            exit 1
          fi
          echo "âœ… Checksums signed and verified"

          # Move public key to artifacts directory for release
          cp ../samoyed-release-public.key .

      - name: ðŸ“‚ Prepare release assets
        run: |
          echo "ðŸ“‚ Organizing release assets..."

          # Create a flat structure for release assets
          mkdir -p release-assets

          # Copy all binary archives and their signatures
          find artifacts/release-* -name "*.tar.gz" -o -name "*.zip" -o -name "*.asc" | while read file; do
            cp "$file" release-assets/
          done

          # Copy checksums, signatures, and public key
          cp artifacts/CHECKSUMS.txt release-assets/
          cp artifacts/CHECKSUMS.txt.asc release-assets/
          cp artifacts/samoyed-release-public.key release-assets/

          # List final release assets
          echo "ðŸ“¦ Final release assets:"
          ls -la release-assets/

      - name: ðŸš€ Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare.outputs.version }}
          name: Samoyed v${{ needs.prepare.outputs.version }}
          body_path: artifacts/changelog/CHANGELOG.md
          prerelease: ${{ needs.prepare.outputs.is_prerelease }}
          files: |
            release-assets/*
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Publish to crates.io
  publish:
    name: ðŸ“¦ Publish to crates.io
    needs: [prepare, release]
    runs-on: ubuntu-latest
    if: |
      github.event.inputs.dry_run != 'true' &&
      needs.prepare.outputs.is_prerelease == 'false'

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ¦€ Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: ðŸ“¦ Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-publish-${{ hashFiles('Cargo.lock') }}

      - name: ðŸ” Verify package
        run: |
          cargo package --verbose
          cargo package --list

      - name: ðŸ“¤ Publish to crates.io
        run: |
          cargo publish --verbose
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

  # Post-release tasks
  post_release:
    name: ðŸ“‹ Post-Release Tasks
    needs: [prepare, release]
    runs-on: ubuntu-latest
    if: github.event.inputs.dry_run != 'true'

    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ’¬ Comment on related issues
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ needs.prepare.outputs.version }}';
            const releaseUrl = `https://github.com/${{ github.repository }}/releases/tag/v${version}`;

            // Find issues that mention this version
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'release'
            });

            for (const issue of issues.data) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `ðŸš€ Released in [v${version}](${releaseUrl})!`
              });
            }

      - name: ðŸ“Š Generate release summary
        run: |
          echo "# ðŸš€ Release Summary: v${{ needs.prepare.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“‹ Release Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Version** | v${{ needs.prepare.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Type** | ${{ needs.prepare.outputs.is_prerelease == 'true' && 'Pre-release' || 'Stable Release' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Release URL** | https://github.com/${{ github.repository }}/releases/tag/v${{ needs.prepare.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Crates.io** | ${{ needs.prepare.outputs.is_prerelease == 'false' && 'âœ… Published' || 'â­ï¸ Skipped (pre-release)' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **GPG Signing** | âœ… All artifacts signed with ed25519 |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ” Security Information" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Signing Key**: ed25519 (fingerprint: 02D1B70CF6D841EEE6876E13F7A6F8331CBBC51F)" >> $GITHUB_STEP_SUMMARY
          echo "- **Public Key**: Available in release assets as \`samoyed-release-public.key\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Signatures**: Detached \`.asc\` files for all binaries" >> $GITHUB_STEP_SUMMARY
          echo "- **Checksums**: SHA256 hashes in signed \`CHECKSUMS.txt\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸŽ¯ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify the release artifacts work correctly" >> $GITHUB_STEP_SUMMARY
          echo "2. Test signature verification process" >> $GITHUB_STEP_SUMMARY
          echo "3. Update documentation if needed" >> $GITHUB_STEP_SUMMARY
          echo "4. Announce the release" >> $GITHUB_STEP_SUMMARY
