# =============================================================================
# SAMOYED RELEASE AUTOMATION WORKFLOW
# =============================================================================
#
# WHAT: Fully automated release pipeline for Samoyed git hooks manager
# WHY: Ensures consistent, reliable releases across multiple platforms
# FEATURES:
#   - Cross-platform binary builds (Linux, macOS, Windows)
#   - GPG signing of all release artifacts
#   - Automated changelog generation from conventional commits
#   - GitHub release creation with artifacts
#   - Conditional crates.io publishing (stable releases only)
#   - Post-release automation (issue notifications, summaries)
#
# TRIGGER CONDITIONS:
#   - Version tags: v1.0.0, v1.0.0-beta.1, etc. (semantic versioning)
#   - Manual dispatch: For testing and emergency releases
#
# RELEASE PIPELINE:
#   1. Validate version consistency between tag and Cargo.toml
#   2. Build optimized binaries for all supported platforms
#   3. Generate structured changelog from git commit history
#   4. Sign all release artifacts with GPG
#   5. Create GitHub release with downloadable artifacts
#   6. Publish to crates.io registry (stable releases only)
#   7. Execute post-release tasks (notifications, summaries)

name: üöÄ Release

# =============================================================================
# WORKFLOW PERMISSIONS
# =============================================================================
# WHAT: GitHub token permissions required for release operations
# WHY: Principle of least privilege - only request necessary permissions
# CONTENTS: write - Create releases, upload artifacts
# PULL-REQUESTS: write - Comment on PRs related to releases
# ISSUES: write - Comment on issues resolved in releases
permissions:
  contents: write
  pull-requests: write
  issues: write

# =============================================================================
# WORKFLOW TRIGGER CONFIGURATION
# =============================================================================
# WHAT: Defines when this release workflow executes
# WHY: Enables both automated (tag-based) and manual releases
on:
  push:
    tags:
      # SYNTAX: Regex pattern for semantic version tags
      # MATCHES: v1.0.0, v2.1.3, v1.0.0-beta.1, v2.0.0-rc.1
      # FORMAT: v{major}.{minor}.{patch}[-{prerelease}]
      - "v[0-9]+.[0-9]+.[0-9]+*"

  # WHAT: Manual workflow trigger with configurable inputs
  # WHY: Allows testing releases, emergency releases, or custom versions
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g., 0.1.0)"
        required: true
        type: string # GitHub Actions input type for text
      dry_run:
        description: "Dry run (skip publishing)"
        required: false
        type: boolean # GitHub Actions input type for checkboxes
        default: false

# =============================================================================
# GLOBAL ENVIRONMENT VARIABLES
# =============================================================================
# WHAT: Environment variables available to all jobs in this workflow
# WHY: Consistent configuration for optimal debugging and output
env:
  CARGO_TERM_COLOR: always # Force colored Cargo output in CI logs
  RUST_BACKTRACE: 1 # Enable detailed stack traces on panics

jobs:
  # =============================================================================
  # JOB 1: RELEASE PREPARATION AND VALIDATION
  # =============================================================================
  # WHAT: Validates version consistency and prepares release metadata
  # WHY: Prevents releases with mismatched versions or invalid tags
  # OUTPUTS: Provides version info and prerelease status to dependent jobs
  prepare:
    name: üîç Prepare Release
    runs-on: ubuntu-latest
    # Job outputs that other jobs can reference via needs.prepare.outputs.*
    # These values determine release behavior (crates.io publishing, GitHub release type)
    outputs:
      version: ${{ steps.version.outputs.version }} # Semantic version (e.g., "1.0.0")
      is_prerelease: ${{ steps.version.outputs.is_prerelease }} # Boolean string indicating pre-release

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v5
        with:
          # WHAT: fetch-depth: 0 downloads complete git history
          # WHY: Required for changelog generation (git log, tag comparison)
          # DEFAULT: fetch-depth: 1 (shallow clone) insufficient for releases
          fetch-depth: 0

      - name: üè∑Ô∏è Determine version
        id: version # Step ID for referencing outputs in other steps
        run: |
          # =================================================================
          # VERSION EXTRACTION LOGIC
          # =================================================================
          # WHAT: Extract version from trigger source (tag or manual input)
          # WHY: Support both automated tag-based and manual releases
          # SYNTAX: github.event_name is built-in context variable

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual trigger: use provided version input
            VERSION="${{ github.event.inputs.version }}"
            TAG="v${VERSION}"  # Prefix with 'v' for consistency
          else
            # Tag trigger: extract version from tag name
            TAG="${{ github.ref_name }}"  # github.ref_name contains tag name
            VERSION="${TAG#v}"           # Remove 'v' prefix using bash parameter expansion
          fi

          # WHAT: Set step outputs for use in other jobs
          # SYNTAX: >> $GITHUB_OUTPUT is GitHub Actions method to set outputs
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT

          # WHAT: Determine if this is a pre-release version
          # WHY: Pre-releases skip crates.io publishing and use different GitHub release flags
          # LOGIC: Semantic version with hyphen indicates pre-release (e.g., 1.0.0-beta.1)
          # SYNTAX: [[ "$VERSION" =~ "-" ]] is bash regex matching
          if [[ "$VERSION" =~ "-" ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "üì¶ Pre-release version detected: ${VERSION}"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "üì¶ Release version: ${VERSION}"
          fi

      - name: üîç Validate Cargo.toml version
        run: |
          # =================================================================
          # VERSION CONSISTENCY VALIDATION
          # =================================================================
          # WHAT: Ensure Cargo.toml version matches release tag
          # WHY: Prevents publishing releases with incorrect version metadata
          # CRITICAL: Cargo publish uses Cargo.toml version, must match tag

          # SYNTAX: Pipeline of commands to extract version from Cargo.toml
          # grep -E "^version" - Find lines starting with "version"
          # head -1 - Take first match (main package version)
          # cut -d'"' -f2 - Split on quotes, take second field (version string)
          CARGO_VERSION=$(grep -E "^version" Cargo.toml | head -1 | cut -d'"' -f2)
          EXPECTED_VERSION="${{ steps.version.outputs.version }}"

          # WHAT: Compare versions and fail if mismatch
          # WHY: Version mismatch would cause publish failures or incorrect releases
          if [[ "$CARGO_VERSION" != "$EXPECTED_VERSION" ]]; then
            echo "‚ùå Version mismatch!"
            echo "Cargo.toml version: ${CARGO_VERSION}"
            echo "Release version: ${EXPECTED_VERSION}"
            echo ""
            echo "Please update Cargo.toml version to match the release tag."
            exit 1  # Fail the workflow with error exit code
          fi

          echo "‚úÖ Version validated: ${CARGO_VERSION}"

  # Build release binaries for all platforms
  build:
    name: üèóÔ∏è Build ${{ matrix.target }}
    needs: prepare
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux builds
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            archive: tar.gz
          - target: aarch64-unknown-linux-gnu
            os: ubuntu-latest
            archive: tar.gz
            cross: true

          # macOS builds
          - target: x86_64-apple-darwin
            os: macos-latest
            archive: tar.gz
          - target: aarch64-apple-darwin
            os: macos-latest
            archive: tar.gz

          # Windows builds
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            archive: zip
          - target: i686-pc-windows-msvc
            os: windows-latest
            archive: zip

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v5

      - name: ü¶Ä Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: üì¶ Install cross-compilation tools
        if: matrix.cross
        run: |
          cargo install cross --git https://github.com/cross-rs/cross

      - name: üì¶ Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
            ${{ matrix.cross && 'target/cross-*' || '' }}
          key: ${{ runner.os }}-cargo-release-${{ matrix.target }}-${{ matrix.cross && 'cross-' || '' }}${{ hashFiles('Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-release-${{ matrix.target }}-${{ matrix.cross && 'cross-' || '' }}
            ${{ runner.os }}-cargo-release-${{ matrix.target }}-
            ${{ runner.os }}-cargo-

      - name: üßπ Clean target directory for cross-compilation
        if: matrix.cross
        run: |
          # Clean target directory to avoid cargo caching issues with build scripts
          # This prevents GLIBC version mismatches when build scripts are reused across targets
          echo "üßπ Cleaning target directory for cross-compilation..."
          cargo clean
        shell: bash

      - name: üèóÔ∏è Build release binaries
        run: |
          if [[ "${{ matrix.cross }}" == "true" ]]; then
            # Use separate target directory for cross-compilation to avoid conflicts
            export CARGO_TARGET_DIR="target/cross-${{ matrix.target }}"
            cross build --release --target ${{ matrix.target }} --verbose
          else
            cargo build --release --target ${{ matrix.target }} --verbose
          fi
        shell: bash

      - name: üì¶ Package release (Unix)
        if: matrix.archive == 'tar.gz'
        run: |
          # Determine target directory based on cross-compilation
          if [[ "${{ matrix.cross }}" == "true" ]]; then
            TARGET_DIR="target/cross-${{ matrix.target }}/${{ matrix.target }}/release"
          else
            TARGET_DIR="target/${{ matrix.target }}/release"
          fi

          # Package from the target directory
          ASSET_NAME="samoyed-${{ needs.prepare.outputs.version }}-${{ matrix.target }}.tar.gz"
          tar czf "${ASSET_NAME}" -C "${TARGET_DIR}" samoyed samoyed-hook
          echo "ASSET=${ASSET_NAME}" >> $GITHUB_ENV

      - name: üì¶ Package release (Windows)
        if: matrix.archive == 'zip'
        shell: bash
        run: |
          # Determine target directory based on cross-compilation
          if [[ "${{ matrix.cross }}" == "true" ]]; then
            TARGET_DIR="target/cross-${{ matrix.target }}/${{ matrix.target }}/release"
          else
            TARGET_DIR="target/${{ matrix.target }}/release"
          fi

          # Package from the target directory
          ASSET_NAME="samoyed-${{ needs.prepare.outputs.version }}-${{ matrix.target }}.zip"
          cd "${TARGET_DIR}"
          7z a "../../../${ASSET_NAME}" samoyed.exe samoyed-hook.exe
          cd ../../../
          echo "ASSET=${ASSET_NAME}" >> $GITHUB_ENV

      - name: üì§ Upload release artifact
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.target }}
          path: ${{ env.ASSET }}
          retention-days: 7

  # Generate changelog for the release
  changelog:
    name: üìù Generate Changelog
    needs: prepare
    runs-on: ubuntu-latest

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: üìù Generate changelog
        id: changelog
        run: |
          # Get the previous tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 ${{ needs.prepare.outputs.tag }}^ 2>/dev/null || echo "")

          if [[ -z "$PREVIOUS_TAG" ]]; then
            echo "üìù Generating changelog for first release..."
            RANGE=""
          else
            echo "üìù Generating changelog from ${PREVIOUS_TAG} to ${{ needs.prepare.outputs.tag }}..."
            RANGE="${PREVIOUS_TAG}..${{ needs.prepare.outputs.tag }}"
          fi

          # Generate changelog using git log with conventional commit parsing
          {
            echo "## What's Changed in ${{ needs.prepare.outputs.version }}"
            echo ""

            # Features
            FEATURES=$(git log ${RANGE} --pretty=format:"%s|%h" | grep -E "^feat(\(.*\))?:" || true)
            if [[ -n "$FEATURES" ]]; then
              echo "### ‚ú® Features"
              echo "$FEATURES" | while IFS='|' read -r message hash; do
                echo "- ${message} (${hash})"
              done
              echo ""
            fi

            # Bug fixes
            FIXES=$(git log ${RANGE} --pretty=format:"%s|%h" | grep -E "^fix(\(.*\))?:" || true)
            if [[ -n "$FIXES" ]]; then
              echo "### üêõ Bug Fixes"
              echo "$FIXES" | while IFS='|' read -r message hash; do
                echo "- ${message} (${hash})"
              done
              echo ""
            fi

            # Performance improvements
            PERF=$(git log ${RANGE} --pretty=format:"%s|%h" | grep -E "^perf(\(.*\))?:" || true)
            if [[ -n "$PERF" ]]; then
              echo "### ‚ö° Performance"
              echo "$PERF" | while IFS='|' read -r message hash; do
                echo "- ${message} (${hash})"
              done
              echo ""
            fi

            # Other changes
            OTHERS=$(git log ${RANGE} --pretty=format:"%s|%h" | grep -vE "^(feat|fix|perf|docs|test|chore|ci|build|style|refactor)(\(.*\))?:" || true)
            if [[ -n "$OTHERS" ]]; then
              echo "### üì¶ Other Changes"
              echo "$OTHERS" | while IFS='|' read -r message hash; do
                echo "- ${message} (${hash})"
              done
              echo ""
            fi

            # Contributors
            echo "### üë• Contributors"
            git log ${RANGE} --pretty=format:"%an|%ae" | sort | uniq | while IFS='|' read -r author email; do
              # Map author names/emails to GitHub usernames
              case "$email" in
                "hello@behrang.org"|"behrangsa@gmail.com")
                  echo "- @behrangsa"
                  ;;
                *)
                  # For unknown contributors, use author name without @ prefix to avoid incorrect mentions
                  echo "- ${author}"
                  ;;
              esac
            done
            echo ""

            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${{ needs.prepare.outputs.tag }}"
          } > CHANGELOG.md

          # Save changelog for release body
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          cat CHANGELOG.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: üì§ Upload changelog
        uses: actions/upload-artifact@v4
        with:
          name: changelog
          path: CHANGELOG.md
          retention-days: 7

  # Create GitHub release
  release:
    name: üöÄ Create Release
    needs: [prepare, build, changelog]
    runs-on: ubuntu-latest
    if: github.event.inputs.dry_run != 'true'

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v5

      - name: üì• Download all artifacts
        uses: actions/download-artifact@v5
        with:
          path: artifacts/

      - name: üìã List artifacts
        run: |
          echo "üì¶ Release artifacts:"
          find artifacts -type f -name "*.tar.gz" -o -name "*.zip" | sort

      - name: üîê Import GPG key
        run: |
          # Import the private key from repository secrets
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import

          # Configure GPG for non-interactive signing
          echo "allow-loopback-pinentry" >> ~/.gnupg/gpg-agent.conf
          gpgconf --reload gpg-agent

          # Verify key was imported successfully (ed25519 key)
          echo "üîç Verifying GPG key import..."
          gpg --list-secret-keys --keyid-format LONG

          # Should show: sec ed25519/${{ vars.GPG_KEY_ID }}
          if ! gpg --list-secret-keys --keyid-format LONG | grep -q "${{ vars.GPG_KEY_ID }}"; then
            echo "‚ùå GPG key import failed"
            exit 1
          fi
          echo "‚úÖ GPG key imported successfully"

      - name: üìú Extract and verify public key
        run: |
          # Extract public key for distribution
          gpg --armor --export ${{ vars.FULL_GPG_KEY_ID }} > samoyed-release-public.key

          # Verify the exported public key
          echo "üîç Verifying exported public key..."
          gpg --import --import-options show-only --with-fingerprint samoyed-release-public.key

          # Verify fingerprint matches expected value (normalize spacing)
          ACTUAL_FINGERPRINT=$(gpg --import --import-options show-only --with-fingerprint samoyed-release-public.key | grep -E '^\s+([0-9A-F]{4}\s*){10}' | tr -s ' ' | xargs)
          EXPECTED_FINGERPRINT="${{ vars.GPG_FINGERPRINT }}"
          
          echo "Expected: ${EXPECTED_FINGERPRINT}"
          echo "Actual:   ${ACTUAL_FINGERPRINT}"
          
          if [[ "${ACTUAL_FINGERPRINT}" != "${EXPECTED_FINGERPRINT}" ]]; then
            echo "‚ùå Public key fingerprint verification failed"
            echo "Expected: ${EXPECTED_FINGERPRINT}"
            echo "Actual:   ${ACTUAL_FINGERPRINT}"
            exit 1
          fi
          echo "‚úÖ Public key exported and verified"

      - name: ‚úçÔ∏è Sign release artifacts
        run: |
          echo "üîê Signing release artifacts with ed25519 key..."

          # Sign each artifact with detached signature
          for file in artifacts/release-*/*.tar.gz artifacts/release-*/*.zip; do
            if [[ -f "$file" ]]; then
              echo "Signing: $(basename "$file")"

              # Create detached ASCII-armored signature with ed25519 key
              gpg --batch --yes \
                --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
                --pinentry-mode loopback \
                --armor \
                --detach-sign \
                --local-user ${{ vars.FULL_GPG_KEY_ID }} \
                --output "${file}.asc" \
                "$file"

              # Verify signature was created correctly
              if ! gpg --verify "${file}.asc" "$file"; then
                echo "‚ùå Signature verification failed for $(basename "$file")"
                exit 1
              fi
              echo "‚úÖ Signed and verified: $(basename "$file")"
            fi
          done

      - name: üìã Generate and sign checksums
        run: |
          echo "üìã Generating SHA256 checksums..."

          # Create SHA256 checksums for all release files
          cd artifacts

          # Generate checksums for all artifacts
          {
            echo "# SHA256 Checksums for Samoyed v${{ needs.prepare.outputs.version }}"
            echo "# Generated on $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""
            find release-* -type f \( -name "*.tar.gz" -o -name "*.zip" \) -print0 | \
              xargs -0 sha256sum | sort
          } > CHECKSUMS.txt

          echo "üìã Checksums generated:"
          cat CHECKSUMS.txt

          # Sign the checksums file with ed25519 key
          echo "üîê Signing checksums file..."
          gpg --batch --yes \
            --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
            --pinentry-mode loopback \
            --armor \
            --detach-sign \
            --local-user ${{ vars.FULL_GPG_KEY_ID }} \
            --output CHECKSUMS.txt.asc \
            CHECKSUMS.txt

          # Verify checksums signature
          if ! gpg --verify CHECKSUMS.txt.asc CHECKSUMS.txt; then
            echo "‚ùå Checksums signature verification failed"
            exit 1
          fi
          echo "‚úÖ Checksums signed and verified"

          # Move public key to artifacts directory for release
          cp ../samoyed-release-public.key .

      - name: üìù Log signing operations
        run: |
          echo "üìù Creating signing audit log..."
          {
            echo "=== SIGNING AUDIT LOG ==="
            echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo "Release: v${{ needs.prepare.outputs.version }}"
            echo "Key ID: ${{ vars.FULL_GPG_KEY_ID }}"
            echo "Workflow: ${{ github.workflow }}"
            echo "Run ID: ${{ github.run_id }}"
            echo "Actor: ${{ github.actor }}"
            echo "Artifacts signed:"
            find artifacts/release-* -name "*.asc" | while read sig; do
              echo "  - $(basename "$sig")"
            done
            echo "========================"
          } > signing-audit.log

      - name: üìÇ Prepare release assets
        run: |
          echo "üìÇ Organizing release assets..."

          # Create a flat structure for release assets
          mkdir -p release-assets

          # Copy all binary archives and their signatures
          find artifacts/release-* -name "*.tar.gz" -o -name "*.zip" -o -name "*.asc" | while read file; do
            cp "$file" release-assets/
          done

          # Copy checksums, signatures, and public key
          cp artifacts/CHECKSUMS.txt release-assets/
          cp artifacts/CHECKSUMS.txt.asc release-assets/
          cp artifacts/samoyed-release-public.key release-assets/
          cp signing-audit.log release-assets/

          # List final release assets
          echo "üì¶ Final release assets:"
          ls -la release-assets/

      - name: üöÄ Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare.outputs.version }}
          name: Samoyed v${{ needs.prepare.outputs.version }}
          body_path: artifacts/changelog/CHANGELOG.md
          prerelease: ${{ needs.prepare.outputs.is_prerelease }}
          files: |
            release-assets/*
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Publish to crates.io
  publish:
    name: üì¶ Publish to crates.io
    needs: [prepare, release]
    runs-on: ubuntu-latest
    if: |
      github.event.inputs.dry_run != 'true' &&
      needs.prepare.outputs.is_prerelease == 'false'

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v5

      - name: ü¶Ä Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: üì¶ Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-publish-${{ hashFiles('Cargo.lock') }}

      - name: üîç Verify package
        run: |
          cargo package --verbose
          cargo package --list

      - name: üì§ Publish to crates.io
        run: |
          cargo publish --verbose
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

  # Post-release tasks
  post_release:
    name: üìã Post-Release Tasks
    needs: [prepare, release]
    runs-on: ubuntu-latest
    if: github.event.inputs.dry_run != 'true'

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v5

      - name: üí¨ Comment on related issues
        uses: actions/github-script@v7
        with:
          script: |
            const version = '${{ needs.prepare.outputs.version }}';
            const releaseUrl = `https://github.com/${{ github.repository }}/releases/tag/v${version}`;

            // Find issues that mention this version
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'release'
            });

            for (const issue of issues.data) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `üöÄ Released in [v${version}](${releaseUrl})!`
              });
            }

      - name: üìä Generate release summary
        run: |
          echo "# üöÄ Release Summary: v${{ needs.prepare.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìã Release Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Version** | v${{ needs.prepare.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Type** | ${{ needs.prepare.outputs.is_prerelease == 'true' && 'Pre-release' || 'Stable Release' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Release URL** | https://github.com/${{ github.repository }}/releases/tag/v${{ needs.prepare.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Crates.io** | ${{ needs.prepare.outputs.is_prerelease == 'false' && '‚úÖ Published' || '‚è≠Ô∏è Skipped (pre-release)' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **GPG Signing** | ‚úÖ All artifacts signed with ed25519 |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üîê Security Information" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Signing Key**: ed25519 (fingerprint: ${{ vars.FULL_GPG_KEY_ID }})" >> $GITHUB_STEP_SUMMARY
          echo "- **Public Key**: Available in release assets as \`samoyed-release-public.key\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Signatures**: Detached \`.asc\` files for all binaries" >> $GITHUB_STEP_SUMMARY
          echo "- **Checksums**: SHA256 hashes in signed \`CHECKSUMS.txt\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üéØ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify the release artifacts work correctly" >> $GITHUB_STEP_SUMMARY
          echo "2. Test signature verification process" >> $GITHUB_STEP_SUMMARY
          echo "3. Update documentation if needed" >> $GITHUB_STEP_SUMMARY
          echo "4. Announce the release" >> $GITHUB_STEP_SUMMARY

  # Verify all signatures
  verify_signatures:
    name: üîç Verify Signatures
    needs: [prepare, release]
    runs-on: ubuntu-latest
    if: github.event.inputs.dry_run != 'true'

    steps:
      - name: üì• Download release assets
        run: |
          echo "üì• Downloading release assets for verification..."
          gh release download v${{ needs.prepare.outputs.version }} --repo ${{ github.repository }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üîê Import public key and verify all signatures
        run: |
          echo "üîê Importing public key and verifying signatures..."

          # Import public key
          gpg --import samoyed-release-public.key

          # Verify key fingerprint (normalize spacing)
          ACTUAL_FINGERPRINT=$(gpg --fingerprint ${{ vars.FULL_GPG_KEY_ID }} | grep -E '^\s+([0-9A-F]{4}\s*){10}' | tr -s ' ' | xargs)
          EXPECTED_FINGERPRINT="${{ vars.GPG_FINGERPRINT }}"
          
          echo "Expected: ${EXPECTED_FINGERPRINT}"
          echo "Actual:   ${ACTUAL_FINGERPRINT}"
          
          if [[ "${ACTUAL_FINGERPRINT}" != "${EXPECTED_FINGERPRINT}" ]]; then
            echo "‚ùå Public key fingerprint verification failed"
            echo "Expected: ${EXPECTED_FINGERPRINT}"
            echo "Actual:   ${ACTUAL_FINGERPRINT}"
            exit 1
          fi
          echo "‚úÖ Public key fingerprint verified"

          # Verify all signatures
          FAILED=0
          echo "üîç Verifying individual signatures..."

          for sig in *.asc; do
            if [[ ! -f "$sig" ]]; then
              continue
            fi

            if [[ "$sig" == "CHECKSUMS.txt.asc" ]]; then
              FILE="CHECKSUMS.txt"
            else
              FILE="${sig%.asc}"
            fi

            if [[ ! -f "$FILE" ]]; then
              echo "‚ùå Missing file for signature: $FILE"
              FAILED=1
              continue
            fi

            if gpg --verify "$sig" "$FILE" 2>/dev/null; then
              echo "‚úÖ $sig: VALID"
            else
              echo "‚ùå $sig: INVALID"
              FAILED=1
            fi
          done

          if [[ $FAILED -eq 1 ]]; then
            echo "‚ùå Signature verification failed"
            exit 1
          fi
          echo "‚úÖ All signatures verified successfully"

  # Security monitoring and alerting
  security_check:
    name: üõ°Ô∏è Security Monitoring
    needs: [prepare, release]
    runs-on: ubuntu-latest
    if: always() && github.event.inputs.dry_run != 'true'

    steps:
      - name: üîç Check release signature completeness
        id: security_check
        run: |
          echo "üîç Performing security checks on release..."

          # Get release info
          RELEASE_INFO=$(gh api repos/${{ github.repository }}/releases/tags/v${{ needs.prepare.outputs.version }})

          # Extract asset names
          ASSETS=$(echo "$RELEASE_INFO" | jq -r '.assets[].name')
          echo "üì¶ Release assets found:"
          echo "$ASSETS"

          # Check if all expected signature files exist
          MISSING_SIGS=""

          # Check binary signatures
          echo "$ASSETS" | grep -E '\.(tar\.gz|zip)$' | while read binary; do
            if ! echo "$ASSETS" | grep -q "${binary}.asc"; then
              echo "‚ùå Missing signature for: $binary"
              echo "SECURITY_ISSUE=true" >> $GITHUB_ENV
            else
              echo "‚úÖ Found signature for: $binary"
            fi
          done

          # Check checksums signature
          if echo "$ASSETS" | grep -q "CHECKSUMS.txt"; then
            if ! echo "$ASSETS" | grep -q "CHECKSUMS.txt.asc"; then
              echo "‚ùå Missing signature for CHECKSUMS.txt"
              echo "SECURITY_ISSUE=true" >> $GITHUB_ENV
            else
              echo "‚úÖ Found signature for CHECKSUMS.txt"
            fi
          else
            echo "‚ùå Missing CHECKSUMS.txt file"
            echo "SECURITY_ISSUE=true" >> $GITHUB_ENV
          fi

          # Check public key presence
          if ! echo "$ASSETS" | grep -q "samoyed-release-public.key"; then
            echo "‚ùå Missing public key file"
            echo "SECURITY_ISSUE=true" >> $GITHUB_ENV
          else
            echo "‚úÖ Found public key file"
          fi

          # Check audit log presence
          if ! echo "$ASSETS" | grep -q "signing-audit.log"; then
            echo "‚ùå Missing signing audit log"
            echo "SECURITY_ISSUE=true" >> $GITHUB_ENV
          else
            echo "‚úÖ Found signing audit log"
          fi

          if [[ "${SECURITY_ISSUE}" == "true" ]]; then
            echo "‚ùå Security check failed - missing required files"
            exit 1
          fi
          echo "‚úÖ All security checks passed"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üö® Alert on security issues
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üö® SECURITY ALERT: Release v${{ needs.prepare.outputs.version }} signature issues',
              body: `**CRITICAL SECURITY ISSUE**: Release v${{ needs.prepare.outputs.version }} has signature verification problems.

              **Immediate Actions Required:**
              1. ‚õî Do not distribute this release to users
              2. üîç Investigate the signing process failure
              3. üîê Check for potential key compromise
              4. üîÑ Re-run the release workflow if needed

              **Details:**
              - **Release:** v${{ needs.prepare.outputs.version }}
              - **Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
              - **Time:** ${new Date().toISOString()}

              **Next Steps:**
              - Review the failed workflow logs above
              - Verify all required signature files are present
              - Check that GPG key is functioning correctly
              - Consider key rotation if compromise is suspected`,
              labels: ['security', 'critical', 'release', 'urgent']
            });
