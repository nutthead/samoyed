# ============================================================================
# CI Pipeline
# ============================================================================
# CI workflow featuring:
# - Rust build caching via Swatinem/rust-cache
# - Parallel job execution across key platforms
# - Fail-fast quick checks before the full test matrix
# - Tool installation via cargo-binstall with fallbacks
# - Coverage reporting and optional PR comments
# - Merge queue support

name: CI

on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches: [master]
  merge_group:
    types: [checks_requested]
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * MON'

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

env:
  RUST_VERSION: "1.90.0"
  CARGO_TERM_COLOR: always
  CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse
  RUST_BACKTRACE: short
  RUSTFLAGS: "-D warnings"

permissions:
  contents: read
  pull-requests: write
  actions: read
  checks: write

jobs:
  quick-check:
    name: Quick Checks
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@02be93da58aa71fb456aa9c43b301149248829d8 # v1.15.1
        with:
          toolchain: 1.90.0
          components: rustfmt, clippy

      - name: Setup Rust cache
        uses: Swatinem/rust-cache@bc2d2e71bd35c5549942babaa51a89c586b981d1 # v2.8.1
        with:
          cache-on-failure: true
          prefix-key: "v2-rust"
          key: quick-check

      - name: Check formatting
        run: cargo fmt --all -- --check

      - name: Clippy (fail-fast)
        run: cargo clippy --all-targets --all-features -- -D warnings

      - name: Check documentation
        run: cargo doc --no-deps --all-features
        env:
          RUSTDOCFLAGS: "-D warnings"

  security:
    name: Security Audit
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@02be93da58aa71fb456aa9c43b301149248829d8 # v1.15.1
        with:
          toolchain: 1.90.0

      - name: Install cargo-binstall
        uses: cargo-bins/cargo-binstall@20aa316bab4942180bbbabe93237858e8d77f1ed # v1.15.5

      - name: Install and run security audit
        run: |
          cargo binstall --force --no-confirm --locked cargo-audit cargo-deny || {
            cargo install --locked cargo-audit
            cargo install --locked cargo-deny
          }

          for tool in cargo-audit cargo-deny; do
            if ! command -v "$tool" >/dev/null 2>&1; then
              echo "${tool} is missing after installation attempts" >&2
              cargo install --locked "$tool"
            fi
          done

          cargo audit --json | tee audit.json
          cargo deny check advisories

      - name: Upload audit results
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: security-audit
          path: audit.json
          retention-days: 30

  installer-test:
    name: Installer Scripts (${{ matrix.platform }})
    needs: [quick-check]
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            platform: Ubuntu
            container: ubuntu:24.04
          - os: ubuntu-latest
            platform: Fedora
            container: fedora:42
          - os: macos-latest
            platform: macOS
            container: ""

    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Install shellcheck
        run: |
          if [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            brew install shellcheck
          else
            sudo apt-get update -qq
            sudo apt-get install -y shellcheck
          fi
        shell: bash

      - name: Validate scripts with shellcheck
        run: |
          echo "=== Validating install.sh ==="
          shellcheck install.sh || echo "Note: SC2016 is expected (intentional quote mixing)"
          echo ""
          echo "=== Validating uninstall.sh ==="
          shellcheck uninstall.sh
        shell: bash

      - name: Test install.sh functions (native)
        if: matrix.container == ''
        run: |
          cat > test_install.sh << 'EOF'
          #!/bin/bash
          set -euo pipefail

          echo "=== Testing install.sh functions ==="
          echo ""

          # Extract and test platform detection
          source <(sed -n '/^detect_platform()/,/^}/p' install.sh)

          echo "Test 1: Platform detection"
          PLATFORM=$(detect_platform 2>&1)
          echo "‚úì Platform detected: $PLATFORM"
          echo ""

          echo "Test 2: Platform format validation"
          if [[ "$PLATFORM" =~ ^(x86_64|aarch64)-(unknown-linux-musl|apple-darwin)$ ]]; then
            echo "‚úì Platform format is correct"
          else
            echo "‚úó Invalid platform format: $PLATFORM"
            exit 1
          fi
          echo ""

          echo "Test 3: Prerequisites check"
          for cmd in curl tar; do
            if command -v "$cmd" >/dev/null 2>&1; then
              echo "‚úì Found: $cmd"
            else
              echo "‚úó Missing: $cmd"
              exit 1
            fi
          done
          echo ""

          echo "=== All tests passed ==="
          EOF

          chmod +x test_install.sh
          bash test_install.sh
        shell: bash

      - name: Test install.sh functions (container)
        if: matrix.container != ''
        run: |
          cat > test_install.sh << 'EOF'
          #!/bin/bash
          set -euo pipefail

          echo "=== Testing install.sh functions ==="
          echo ""

          # Extract and test platform detection
          source <(sed -n '/^detect_platform()/,/^}/p' /workspace/install.sh)

          echo "Test 1: Platform detection"
          PLATFORM=$(detect_platform 2>&1)
          echo "‚úì Platform detected: $PLATFORM"
          echo ""

          echo "Test 2: Prerequisites check"
          for cmd in curl tar; do
            if command -v "$cmd" >/dev/null 2>&1; then
              echo "‚úì Found: $cmd"
            else
              echo "‚úó Missing: $cmd"
              exit 1
            fi
          done
          echo ""

          echo "=== All tests passed ==="
          EOF

          chmod +x test_install.sh

          if [[ "${{ matrix.platform }}" == "Fedora" ]]; then
            docker run --rm -v "$PWD:/workspace" ${{ matrix.container }} bash -c "dnf install -y -q curl tar && bash /workspace/test_install.sh"
          else
            docker run --rm -v "$PWD:/workspace" ${{ matrix.container }} bash -c "apt-get update -qq && apt-get install -y -qq curl && bash /workspace/test_install.sh"
          fi
        shell: bash

      - name: Test uninstall.sh
        run: |
          cat > test_uninstall.sh << 'EOF'
          #!/bin/bash
          set -euo pipefail

          echo "=== Testing uninstall.sh ==="
          echo ""

          # Create mock installation
          mkdir -p "$HOME/.local/bin"
          echo '#!/bin/sh' > "$HOME/.local/bin/samoyed"
          echo 'echo "mock"' >> "$HOME/.local/bin/samoyed"
          chmod +x "$HOME/.local/bin/samoyed"
          echo "‚úì Created mock binary"
          echo ""

          # Run uninstall
          bash uninstall.sh
          echo ""

          # Verify removal
          if [ ! -f "$HOME/.local/bin/samoyed" ]; then
            echo "‚úì Binary successfully removed"
          else
            echo "‚úó Binary still exists"
            exit 1
          fi

          echo "=== Uninstall test passed ==="
          EOF

          chmod +x test_uninstall.sh
          bash test_uninstall.sh
        shell: bash

  test:
    name: Test ${{ matrix.name }}
    needs: [quick-check]
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            name: Linux
            target: x86_64-unknown-linux-gnu
            test_args: ""

          - os: macos-14
            name: macOS (ARM)
            target: aarch64-apple-darwin
            test_args: ""

          - os: windows-latest
            name: Windows
            target: x86_64-pc-windows-msvc
            test_args: ""

          - os: ubuntu-latest
            name: Linux (musl)
            target: x86_64-unknown-linux-musl
            test_args: ""

    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@02be93da58aa71fb456aa9c43b301149248829d8 # v1.15.1
        with:
          toolchain: 1.90.0
          target: ${{ matrix.target }}
          components: clippy, rustfmt

      - name: Setup Rust cache
        uses: Swatinem/rust-cache@bc2d2e71bd35c5549942babaa51a89c586b981d1 # v2.8.1
        with:
          cache-on-failure: true
          prefix-key: "v2-rust"
          key: ${{ matrix.target }}-${{ matrix.name }}
          save-if: ${{ github.ref == 'refs/heads/master' }}

      - name: Install musl tools
        if: contains(matrix.target, 'musl')
        run: |
          sudo apt-get update
          sudo apt-get install -y musl-tools

      - name: Build
        run: cargo build --locked --target ${{ matrix.target }} ${{ matrix.test_args }}

      - name: Run tests
        run: cargo test --locked --target ${{ matrix.target }} ${{ matrix.test_args }} -- --test-threads=1

      - name: Integration tests
        run: |
          cargo build --locked --release --target ${{ matrix.target }}
          for script in tests/integration/*.sh; do
            echo "Running ${script}"
            bash "$script"
          done
        shell: sh

  coverage:
    name: Code Coverage
    needs: [test]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      - name: Install Rust toolchain
        uses: actions-rust-lang/setup-rust-toolchain@02be93da58aa71fb456aa9c43b301149248829d8 # v1.15.1
        with:
          toolchain: 1.90.0

      - name: Setup Rust cache
        uses: Swatinem/rust-cache@bc2d2e71bd35c5549942babaa51a89c586b981d1 # v2.8.1
        with:
          cache-on-failure: false
          save-if: false

      - name: Install cargo-binstall
        uses: cargo-bins/cargo-binstall@20aa316bab4942180bbbabe93237858e8d77f1ed # v1.15.5

      - name: Install and run tarpaulin
        run: |
          cargo binstall --force --no-confirm --locked cargo-tarpaulin || cargo install --locked cargo-tarpaulin

          if ! command -v cargo-tarpaulin >/dev/null 2>&1; then
            echo "cargo-tarpaulin binary missing after installation attempts" >&2
            cargo install --locked cargo-tarpaulin
          fi

          cargo tarpaulin --timeout 120 --avoid-cfg-tarpaulin

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@af09b5e394c93991b95a5e7646aeb90c1917f78f # v5.5.1
        with:
          files: target/tarpaulin/cobertura.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

      - name: Install coverage parser
        if: github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false
        run: npm install fast-xml-parser@5.2.5 dedent@1.7.0 --no-save --no-package-lock

      - name: Comment coverage on PR
        if: github.event_name == 'pull_request' && github.event.pull_request.head.repo.fork == false
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            const fs = require('fs');
            const { XMLParser } = require('fast-xml-parser');
            const dedent = require('dedent');

            const parser = new XMLParser({
              ignoreAttributes: false,
              attributeNamePrefix: ''
            });

            const rawXml = fs.readFileSync('target/tarpaulin/cobertura.xml', 'utf8');
            const parsed = parser.parse(rawXml);
            const coverage = parsed.coverage;

            const linesCovered = Number(coverage['lines-covered'] ?? 0);
            const linesValid = Number(coverage['lines-valid'] ?? 0);
            const lineRate = Number(coverage['line-rate'] ?? 0);
            const lineCoveragePercent = (lineRate * 100).toFixed(2);

            const branchesCovered = Number(coverage['branches-covered'] ?? 0);
            const branchesValid = Number(coverage['branches-valid'] ?? 0);
            const branchRate = Number(coverage['branch-rate'] ?? 0);
            const branchCoveragePercent = branchesValid > 0
              ? `${(branchRate * 100).toFixed(2)}%`
              : 'N/A';

            const complexity = coverage.complexity ?? 'N/A';
            const timestampSeconds = Number(coverage.timestamp);
            const timestamp = Number.isFinite(timestampSeconds)
              ? new Date(timestampSeconds * 1000).toISOString()
              : 'N/A';

            const packages = coverage.packages?.package ?? [];
            const packageList = Array.isArray(packages) ? packages : [packages];
            const classList = packageList.flatMap(pkg => {
              const classes = pkg?.classes?.class ?? [];
              return Array.isArray(classes) ? classes : [classes];
            }).filter(Boolean);

            const fileSummaries = classList.map(cls => {
              const filename = cls?.filename;
              const fileLineRate = Number(cls?.['line-rate'] ?? 0);
              return filename ? {
                filename,
                coverage: Number.isFinite(fileLineRate) ? (fileLineRate * 100).toFixed(1) : 'N/A'
              } : null;
            }).filter(Boolean);

            const filesReported = fileSummaries.length;
            const detailedReport = fileSummaries.length > 0
              ? fileSummaries
                  .sort((a, b) => a.filename.localeCompare(b.filename))
                  .map(({ filename, coverage }) => `${filename}: ${coverage}%`)
                  .join('\n')
              : 'No per-file coverage data available.';

            const coverageTable = `| Metric | Covered | Total | Rate |\n` +
              `|--------|--------:|------:|------:|\n` +
              `| Lines | ${linesCovered} | ${linesValid} | ${lineCoveragePercent}% |\n` +
              `| Branches | ${branchesCovered} | ${branchesValid} | ${branchCoveragePercent} |`;

            const metadataTable = `| Additional Metric | Value |\n` +
              `|-------------------|-------|\n` +
              `| Complexity | ${complexity} |\n` +
              `| Files Reported | ${filesReported} |\n` +
              `| Report Timestamp | ${timestamp} |`;

            const body = dedent`
              ## üìä Coverage Report

              ${coverageTable}

              ${metadataTable}

              <details>
              <summary>View detailed report</summary>

              \`\`\`
              ${detailedReport}
              \`\`\`

              </details>

              ---
              *Generated by cargo-tarpaulin*
            `;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body
            });

  ci-success:
    name: CI Success
    if: always()
    needs: [quick-check, security, installer-test, test, coverage]
    runs-on: ubuntu-latest
    steps:
      - name: Check status
        run: |
          if [[ "${{ needs.quick-check.result }}" != "success" ]] ||
             [[ "${{ needs.installer-test.result }}" != "success" ]] ||
             [[ "${{ needs.test.result }}" != "success" ]] ||
             [[ "${{ needs.coverage.result }}" != "success" ]]; then
            echo "‚ùå CI failed"
            exit 1
          fi
          echo "‚úÖ All CI checks passed"

      - name: Set merge queue status
        if: github.event_name == 'merge_group'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8
        with:
          script: |
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'CI Status',
              head_sha: context.sha,
              status: 'completed',
              conclusion: 'success',
              output: {
                title: 'CI Passed',
                summary: 'All CI checks completed successfully'
              }
            });
